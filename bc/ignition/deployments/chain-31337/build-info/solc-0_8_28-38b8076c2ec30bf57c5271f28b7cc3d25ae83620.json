{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-38b8076c2ec30bf57c5271f28b7cc3d25ae83620",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EVoting.sol": "project/contracts/EVoting.sol",
    "contracts/Verifier.sol": "project/contracts/Verifier.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EVoting.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Verifier.sol\";\n\ncontract EVoting {\n    struct Candidate {\n        string name;\n        uint256 voteCount;\n    }\n\n    mapping(address => bool) public hasVoted;\n    Candidate[] public candidates;\n    Groth16Verifier public verifier;\n\n    event VoteCast(address indexed voter, uint256 indexed candidateIndex);\n\n    constructor(address _verifier) {\n        verifier = Groth16Verifier(_verifier);\n\n        // Store candidates permanently on-chain\n        candidates.push(Candidate(\"Alice\", 0));\n        candidates.push(Candidate(\"Bob\", 0));\n        candidates.push(Candidate(\"Charlie\", 0));\n    }\n\n    function vote(\n        uint256 candidateIndex,\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[1] memory input\n    ) public {\n        require(candidateIndex < candidates.length, \"Invalid candidate\");\n        require(!hasVoted[msg.sender], \"Already voted\");\n\n        // zkSNARK proof verification\n        bool verified = verifier.verifyProof(a, b, c, input);\n        require(verified, \"Invalid proof\");\n\n        // Optional eligibility check (depends on your circuit)\n        require(input[0] == 1, \"Not eligible to vote\");\n\n        candidates[candidateIndex].voteCount += 1;\n        hasVoted[msg.sender] = true;\n\n        emit VoteCast(msg.sender, candidateIndex);\n    }\n\n    // Fetch all candidates and votes\n    function getCandidates() public view returns (Candidate[] memory) {\n        return candidates;\n    }\n\n    // Fetch a specific candidate's vote count\n    function getVoteCount(uint256 candidateIndex) public view returns (uint256) {\n        require(candidateIndex < candidates.length, \"Invalid index\");\n        return candidates[candidateIndex].voteCount;\n    }\n}\n"
      },
      "project/contracts/Verifier.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 15936124316567775118861310631028762837117324103839930148910100288420200436996;\n    uint256 constant alphay  = 3084228874827772922604721047803215781863852933344917323871716764803155674062;\n    uint256 constant betax1  = 8182116811774474421696310148573746881700877303279193025369434129406248139329;\n    uint256 constant betax2  = 1787173499763113910800798215420006153127412210725264354407385104431688734292;\n    uint256 constant betay1  = 7356760718302642356953547057610504760442235517221916310318595152122153103682;\n    uint256 constant betay2  = 21068145404204854133472637904708797316414443577604839831091722385891951947878;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 19794541319844033690758407030690039583759587370088461043275328586891433519110;\n    uint256 constant deltax2 = 3275363184571372477414403837385533277874493219184434902813775003348596909085;\n    uint256 constant deltay1 = 17767009246051550865545294783238935965722678944787744346905589643722996463637;\n    uint256 constant deltay2 = 21523623257403516750973701615937162249040440691169139288433091415974505773766;\n\n    \n    uint256 constant IC0x = 11174308194987225177452100641456436732054575230901783115408632762555789603534;\n    uint256 constant IC0y = 17686896455622421126193386100098087797370215357879026308905720548600686046721;\n    \n    uint256 constant IC1x = 18917887246049395077688163512805516172242298296973065238988243410865620559592;\n    uint256 constant IC1y = 2330727997296772103872744892509922348947208853053781286809564089885142942881;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[1] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, r)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations âˆˆ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
      }
    }
  }
}